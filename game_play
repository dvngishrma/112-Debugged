from cmu_graphics import *
import random

           
#easy for representation, hard to update, maneuever, will reqiuire things like flatten for moving things around and getting information to the other codes



carCoords=[['A','v',2,1,2],
                ['B','v',3,1,4],
                ['C','v',2,2,5],
                ['D','h',3,3,0],
                ['E','v',2,4,0],
                ['F','v',2,4,1],
                ['G','v',2,4,2],
                ['H','h',2,4,4],
                ['I','h',2,5,4],
                ['Bug','h',2,2,0]]

#easy to create the pieces and place them on the board, easy to update row col and move pieces around, solution generator might take some thinky thinky


#might want to switch between the two formats, depending on what functionality im using?

                
class Vehicle:
    def __init__(self, name, orient, length, row, col):
        self.name=name
        self.orientation=orient
        self.length=length
        self.row=row
        self.col=col
        
        if self.orientation=='h':
            self.dx=length
            self.dy=1
        else:
            self.dy=length
            self.dx=1
        self.selected=False
        colorList=['blue','orange','green','pink','yellow','purple']
        if name=='Bug':
            self.color='red'
        else:
            self.color=colorList[random.randint(0,len(colorList)-1)]
    def drawCars(self, app):
        cellLeft, cellTop = getCellLeftTop(app, self.row, self.col)
        cellWidth, cellHeight = getCellSize(app)
        numberOfCells=self.length
        if self.selected==True:
            drawRect(cellLeft, cellTop, cellWidth*self.dx, cellHeight*self.dy,
                    fill=self.color, border='white',
                    borderWidth=app.cellBorderWidth, opacity=50)
        else:
            drawRect(cellLeft, cellTop, cellWidth*self.dx, cellHeight*self.dy,
                    fill=self.color, border='black',
                    borderWidth=app.cellBorderWidth)
            
            

carList=[]
for cars in carCoords:
    carList.append(Vehicle(cars[0],cars[1],cars[2],cars[3],cars[4]))


def onAppStart(app):
    app.rows = 6
    app.cols = 6
    app.boardLeft = 50
    app.boardTop = 50
    app.boardWidth = 300
    app.boardHeight = 300
    app.cellBorderWidth = 2
    app.boardList=unpack(app,carList)


def redrawAll(app):
    drawGameState(app,carList)
        
def drawGameState(app,cars):  
    drawBoard(app)
    for car in cars:
        car.drawCars(app)
    drawBoardBorder(app)
    exitX=app.boardLeft+app.boardWidth
    exitY=app.boardTop+(app.boardHeight/app.rows)*2
    drawLine(exitX,exitY,exitX,exitY+(app.boardHeight/app.rows),fill='white',lineWidth=10)
    drawLabel('EXIT',exitX+10,exitY+(app.boardHeight/(2*app.rows)), fill='red', rotateAngle=90)

def drawBoard(app):
    for row in range(app.rows):
        for col in range(app.cols):
            drawCell(app, row, col)

def drawBoardBorder(app):
  # draw the board outline (with double-thickness):
  drawRect(app.boardLeft, app.boardTop, app.boardWidth, app.boardHeight,
           fill=None, border='black',
           borderWidth=2*app.cellBorderWidth)

def drawCell(app, row, col):
    cellLeft, cellTop = getCellLeftTop(app, row, col)
    cellWidth, cellHeight = getCellSize(app)
    drawRect(cellLeft, cellTop, cellWidth, cellHeight,
             fill=None, border='black',
             borderWidth=app.cellBorderWidth)

def getCellLeftTop(app, row, col):
    cellWidth, cellHeight = getCellSize(app)
    cellLeft = app.boardLeft + col * cellWidth
    cellTop = app.boardTop + row * cellHeight
    return (cellLeft, cellTop)

def getCellSize(app):
    cellWidth = app.boardWidth / app.cols
    cellHeight = app.boardHeight / app.rows
    return (cellWidth, cellHeight)


def onMousePress(app,mouseX,mouseY):
    for car in carList:
        carLeft,carTop= getCellLeftTop(app, car.row, car.col)
        carWidth, carHeight = getCellSize(app)
        if carLeft<=mouseX<=carLeft+(carWidth*car.dx) and carTop<=mouseY<=carTop+(carHeight*car.dy):
            car.selected=not(car.selected)
        else: 
            car.selected=False

def onKeyPress(app,key):
    for car in carList:
        if car.selected==True:
            if car.orientation=='h':
                if key=='right':
                    dx=1
                    dy=0
                elif key=='left':
                    dx=-1
                    dy=0
                else:
                    dx=0
                    dy=0
            elif car.orientation=='v':
                if key=='down':
                    dx=0
                    dy=1
                elif key=='up':
                    dx=0
                    dy=-1
                else:
                    dx=0
                    dy=0
            if isLegalMove(app,car, dx ,dy):
                car.row+=dy
                car.col+=dx
                app.boardList=unpack(app,carList)

def isLegalMove(app, car, moveX,moveY ):
    board=app.boardList
    if moveX in (-1,1):
        if moveX==1:
            if (car.col+car.length-1<app.cols-1) and (board[car.row][car.col+car.length]== None):
                return True
        else:
            if (car.col>0) and (board[car.row][car.col-1]== None):
                return True
    elif moveY in (-1,1):
        if moveY==1:
            if (car.row+car.length-1<app.rows-1) and (board[car.row+car.length][car.col]== None) :
                return True
        else:
            if car.row>0 and (board[car.row-1][car.col]== None):
                return True
    elif moveX==0 and moveY==0:
        return True
    return False

def unpack(app,carList):
    #go from the coordinate list of cars to a 2D board repr
    board=[]
    for row in range(app.rows):
        rowList=[]
        for col in range(app.cols):
            rowList.append(None)
        board.append(rowList)
    for car in carList:
        for row in range(car.dy):
            for col in range(car.dx):
                board[car.row+row][car.col+col]=car.name
    return board

def main():
    runApp()


main()